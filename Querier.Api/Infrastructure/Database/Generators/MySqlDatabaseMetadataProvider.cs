using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.Linq;
using Microsoft.Extensions.Logging;
using MySqlConnector;
using Querier.Api.Domain.Entities.DBConnection;
using Querier.Api.Domain.Entities.QDBConnection;
using Querier.Api.Infrastructure.Database.Templates;

namespace Querier.Api.Infrastructure.Database.Generators;

public class MySqlDatabaseMetadataProvider(ILogger logger) : DatabaseMetadataProviderBase, IDatabaseMetadataProvider
{
    public List<StoredProcedureMetadata> ExtractStoredProcedureMetadata(string connectionString)
    {
        List<StoredProcedureMetadata> result = [];
        
        using var connection = new MySqlConnection(connectionString);
        connection.Open();
        logger.LogDebug("Database connection opened successfully");

        using var cmd = connection.CreateCommand();

        cmd.CommandText = @"
            SELECT ROUTINE_SCHEMA, ROUTINE_NAME
            FROM INFORMATION_SCHEMA.ROUTINES
            WHERE ROUTINE_TYPE = 'PROCEDURE'
              AND ROUTINE_SCHEMA = DATABASE()
            ORDER BY ROUTINE_NAME";

        using (var reader = cmd.ExecuteReader())
        {
            while (reader.Read())
            {
                string schemaName = reader.GetString(0);
                string procedureName = reader.GetString(1);

                logger.LogDebug("Processing stored procedure: {ProcedureName}", procedureName);

                var procedure = new StoredProcedureMetadata
                {
                    Schema = schemaName,
                    Name = procedureName,
                    CSName = NormalizeCsString(procedureName),
                    Parameters = [],
                    OutputSet = []
                };
            
                result.Add(procedure);
                logger.LogInformation("Successfully processed stored procedure: {ProcedureName}", procedureName);
            }
        }

        List<string> procedureToRemove = [];
        foreach (var procedure in result)
        {
            try
            {
                procedure.Parameters = GetProcedureParametersMetadata(connection, procedure.Schema, procedure.Name);
            }
            catch (Exception e)
            {
                procedureToRemove.Add(procedure.Name);
                logger.LogDebug(e, "Unable to get parameters metadata for procedure {procedure}", procedure.Name);
            }

            try
            {
                procedure.OutputSet = GetProcedureOutputMetadata(connection, procedure.Schema, procedure.Name, procedure.Parameters.Count);
            }
            catch (Exception e)
            {
                procedureToRemove.Add(procedure.Name);
                logger.LogDebug(e, "Unable to get outputset metadata for procedure {procedure}", procedure.Name);
            }
            
        }

        foreach (var index in procedureToRemove.Select(procedureName => result.FindIndex(p => p.Name == procedureName)))
        {
            result.RemoveAt(index);
        }
        return result;
    }

    private List<TemplateProperty> GetProcedureOutputMetadata(MySqlConnection connection, string schemaName, string procedureName, int parametersCount)
    {
        List<TemplateProperty> result = [];
        using (var transaction = connection.BeginTransaction())
        {
            using var cmd = connection.CreateCommand();

            string safeName = procedureName.Replace("`", "``");
            var paramPlaceholder = string.Join(", ", new int[parametersCount].Select(p => "NULL"));
            cmd.CommandText = $"CALL `{safeName}`({paramPlaceholder});";
            cmd.Transaction = transaction;

            using var reader = cmd.ExecuteReader(CommandBehavior.SchemaOnly);
            var schemaTable = reader.GetSchemaTable();
            if (schemaTable == null)
                throw new Exception("Unable to get procedure output schema");

            int order = 0;
            foreach (DataRow row in schemaTable.Rows)
            {
                var outputSet = new TemplateProperty
                {
                    Name = row["ColumnName"] as string ?? string.Empty,

                    CSName = NormalizeCsString((string)row["ColumnName"]),
                    IsKey = false,
                    IsForeignKey = false,
                    IsRequired = true,
                    IsAutoGenerated = false,
                    SqlParameterType = "",
                    CSType = row["DataType"].ToString()

                };

                result.Add(outputSet);
                logger.LogDebug("Added output {OutputName} to procedure {ProcedureName}", outputSet.Name,
                    procedureName);
            }
            transaction.Rollback();
        }

        return result;
    }

    private List<TemplateProperty> GetProcedureParametersMetadata(MySqlConnection connection, string schemaName, string procedureName)
    {
        List<TemplateProperty> result = [];
        
        using var cmd = connection.CreateCommand();
        cmd.CommandText = @"
        SELECT
            PARAMETER_NAME AS Parameter,
            DATA_TYPE AS Type,
            CHARACTER_MAXIMUM_LENGTH AS Length,
            NUMERIC_PRECISION AS `ParamPrecision`,
            NUMERIC_SCALE AS `ParamScale`,
            ORDINAL_POSITION AS `Order`,
            CASE WHEN PARAMETER_MODE = 'OUT' THEN 1 ELSE 0 END AS is_Output,
            1 AS is_nullable
        FROM INFORMATION_SCHEMA.PARAMETERS
        WHERE SPECIFIC_SCHEMA = DATABASE()
        AND SPECIFIC_NAME = @procName
        ORDER BY ORDINAL_POSITION";

        cmd.Parameters.Add(new MySqlParameter("@procName", procedureName));

        using var reader = cmd.ExecuteReader();
        while (reader.Read())
        {
            var parameter = new TemplateProperty
            {
                Name = reader["Parameter"] as string ?? string.Empty,
                CSName = NormalizeCsString((string)reader["Parameter"]),
                IsKey = false,
                IsForeignKey = false,
                IsRequired = true,
                IsAutoGenerated = false,
                SqlParameterType = ((string)reader["Type"]) switch
                {
                    "bigint" => "System.Data.SqlDbType.BigInt",
                    "bit" => "System.Data.SqlDbType.Bit",
                    "char" => "System.Data.SqlDbType.Char",
                    "date" => "System.Data.SqlDbType.DateTime",
                    "datetime" => "System.Data.SqlDbType.DateTime",
                    "decimal" => "System.Data.SqlDbType.Decimal",
                    "float" => "System.Data.SqlDbType.Float",
                    "int" => "System.Data.SqlDbType.Int",
                    "longtext" => "System.Data.SqlDbType.Text",
                    "mediumint" => "System.Data.SqlDbType.Int",
                    "mediumtext" =>"System.Data.SqlDbType.Text",
                    "smallint" => "System.Data.SqlDbType.SmallInt",
                    "text" => "System.Data.SqlDbType.Text",
                    "time" => "System.Data.SqlDbType.Time",
                    "timestamp" => "System.Data.SqlDbType.Timestamp",
                    "tinyint" => "System.Data.SqlDbType.TinyInt",
                    "tinytext" => "System.Data.SqlDbType.Text",
                    "varbinary" => "System.Data.SqlDbType.Binary",
                    "varchar" => "System.Data.SqlDbType.NVarChar",
                    _ => "object"
                },
                CSType = ((string)reader["Type"]) switch
                    {
                        "bigint" => "long?",
                        "bit" => "bool?",
                        "char" => "char?",
                        "date" => "DateTime?",
                        "datetime" => "DateTime?",
                        "decimal" => "decimal?",
                        "float" => "float?",
                        "int" => "int?",
                        "longtext" => "string?",
                        "mediumint" => "int?",
                        "mediumtext" => "string?",
                        "smallint" => "short?",
                        "text" => "string?",
                        "time" => "TimeOnly?",
                        "timestamp" => "DateTime?", 
                        "tinyint" => "byte?",
                        "tinytext" => "string?",
                        "varbinary" => "byte[]?",
                        "varchar" => "string?",
                        _ => "object?"
                    }
            };

            result.Add(parameter);
            logger.LogDebug("Added parameter {ParameterName} to procedure {ProcedureName}", parameter.Name, procedureName);
        }

        return result;
    }
}