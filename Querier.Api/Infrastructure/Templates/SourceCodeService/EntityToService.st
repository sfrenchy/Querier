using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Dynamic.Core;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Querier.Api.Domain.Common.Attributes;
using Querier.Api.Domain.Common.Models;
using Querier.Api.Common.Utilities;
using Microsoft.Extensions.Caching.Distributed;
using Newtonsoft.Json;
using Querier.Api.Application.DTOs;
using Querier.Api.Infrastructure.Base;
using Querier.Api.Infrastructure.Base.Exceptions;
using $model.RootNamespace$.Dtos;
using $model.RootNamespace$.Repositories;
using $model.RootNamespace$.Entities;

namespace $model.RootNamespace$.Services;

[DynamicContextEntity(ContextName="$model.RootNamespace$.Contexts.$model.RootNamespace$DbContext", ServiceName="I$model.Entity.Name$Service")]
public class $model.Entity.Name$Service : DynamicContextServiceBase<$model.Entity.Name$Service>, I$model.Entity.Name$Service
{
    private readonly I$model.Entity.Name$Repository _repository;
    $model.Entity.ForeignKeys: {fk|
    private readonly I$fk.ReferencedEntitySingular$Service _$fk.ReferencedEntitySingular$Service;
    }$
    
    public $model.Entity.Name$Service(
        I$model.Entity.Name$Repository repository,
        $model.Entity.ForeignKeys: {fk|
        I$fk.ReferencedEntitySingular$Service $fk.ReferencedEntitySingular$Service,
        }$
        IDistributedCache cache,
        ILogger<$model.Entity.Name$Service> logger) : base(cache, logger)
    {
        CACHE_VERSION_KEY = "$model.Entity.Name$_CacheVersion";
        _repository = repository ?? throw new ArgumentNullException(nameof(repository));
        $model.Entity.ForeignKeys: {fk|
            _$fk.ReferencedEntitySingular$Service = $fk.ReferencedEntitySingular$Service ?? throw new ArgumentNullException(nameof($fk.ReferencedEntitySingular$Service));
        }$
        _logger.LogDebug("Initializing $model.Entity.Name$Service");
    \}

    /// <summary>
    /// Maps an entity to its DTO representation
    /// </summary>
    private static Get$model.Entity.Name$Dto MapToDto($model.Entity.Name$ entity)
    {
        if (entity == null)
            throw new ArgumentNullException(nameof(entity));

        return new Get$model.Entity.Name$Dto
        {
            $model.Entity.Properties: {property|
            $property.Name$ = entity.$property.Name$,
            }$
        \};
    \}
    $if (model.Entity.IsTableEntity)$
        /// <summary>
        /// Maps creation DTO data to an entity
        /// </summary>
        private static $model.Entity.Name$ MapToEntity(Create$model.Entity.Name$Dto dto)
        {
            if (dto == null)
                throw new ArgumentNullException(nameof(dto));

            return new $model.Entity.Name$
        {
            $model.Entity.Properties: {property|
            $if(!property.IsAutoGenerated)$
                $property.Name$ = dto.$property.Name$,
            $endif$
            }$
            \};
        \}

        /// <summary>
        /// Maps update DTO data to an entity
        /// </summary>
        private static $model.Entity.Name$ MapToEntity(Update$model.Entity.Name$Dto dto, $model.Entity.MethodSignatureParameter$)
        {
            if (dto == null)
                throw new ArgumentNullException(nameof(dto));

            return new $model.Entity.Name$
        {
            $model.Entity.Properties: {property|
            $if(!property.IsKey)$
                $property.Name$ = dto.$property.Name$,
            $else$
                $property.Name$ = $property.CSParameterName$,
            $endif$
            }$
            \};
        \}
    $endif$

    public async Task<DataPagedResult<Get$model.Entity.Name$Dto>> GetAllAsync(DataRequestParametersDto? parameters = null) {
        try {
            var version = await _cache.GetStringAsync(CACHE_VERSION_KEY) ?? "0";
            var cacheKey = "$model.Entity.Name$_GetAll_" + version + "_" + Utils.ComputeMd5Hash(JsonConvert.SerializeObject(parameters));
            return await ExecuteCacheOperationAsync("$model.RootNamespace$","GetAll", cacheKey, async () => {
                var entitiesResult = await _repository.GetAllAsync(parameters);

                List<ForeignKeyDataDto> resultForeignKeys = new List<ForeignKeyDataDto>();
                    
                foreach (ForeignKeyIncludeDto include in parameters.Includes)
                {
                    ForeignKeyDataDto foreignKeyDataDto = new ForeignKeyDataDto();
                    switch (include.ForeignKey)
                    {
                        default:
                            _logger.LogWarning("Unknown foreign key " + include.ForeignKey + " requested for entity $model.Entity.Name$");
                            break;
                        $model.Entity.ForeignKeys: {fk|
                        case "$fk.Name$":
                        {
                            _logger.LogInformation("Handling foreign key " + include.ForeignKey + " for entity Orders");
                            List<ColumnSearchDto> searchDto = entitiesResult.Items
                                                                    .Select(i => i.$fk.Name$)
                                                                    .Select(i => new ColumnSearchDto() { Column = "$fk.Name$", Value = i.ToString() \})
                                                                    .ToList();
                            _logger.LogInformation("Ids for $fk.Name$:" + string.Join(",", searchDto.Select(s => s.Value)));
                            var foreignKeyData = await _$fk.ReferencedEntitySingular$Service.GetAllAsync(new DataRequestParametersDto()
                            {
                                Includes = new List<ForeignKeyIncludeDto>(),
                                ColumnSearches = searchDto,
                                GlobalSearch = "",
                                OrderBy = new List<OrderByParameterDto>(),
                                PageNumber = 0,
                                PageSize = 0
                            \});
                                
                            foreignKeyDataDto.ForeignKey = "$fk.Name$";
                            foreignKeyDataDto.Values = foreignKeyData.Items.Select(i =>
                                new ForeignKeyValueDto()
                                    { Id = i.KeyIdsAsString(), Value = Utils.FormatForeignKeyValue(i, include) \});
                                
                            resultForeignKeys.Add(foreignKeyDataDto);
                            break;
                        \}
                        }$
                    \}
                \}

                return new DataPagedResult<Get$model.Entity.Name$Dto>(
                    entitiesResult.Items.Select(e => MapToDto(e)),
                    entitiesResult.Total,
                    parameters,
                    resultForeignKeys
                );
            \});
        \}
        catch (Exception ex) when (ex is not DynamicContextException) {
            throw new DatabaseOperationException("$model.RootNamespace$", "GetAll", "$model.Entity.Name$", ex);
        \}
    \}

    $if (model.Entity.IsTableEntity)$
        public async Task<Get$model.Entity.Name$Dto?> GetByIdAsync($model.Entity.MethodSignatureParameter$) {
            $model.Entity.ParametersNamesArray: {parameter|
                if ($parameter$ == null) {
                    throw new EntityValidationException("$model.RootNamespace$", "$model.Entity.Name$", "$parameter$ cannot be null");
                \}
            }$
            try {
                var cacheKey = \$"$model.Entity.Name$_GetById_$model.Entity.CacheKeyIdentifier$";
                var result = await ExecuteCacheOperationAsync<Get$model.Entity.Name$Dto?>("$model.RootNamespace$","GetById", cacheKey, async () => {
                    var entity = await _repository.GetByIdAsync($model.Entity.KeyParameterLine$);
                    if (entity == null) {
                        throw new EntityNotFoundException("$model.RootNamespace$", "$model.Entity.Name$", \$"$model.Entity.StringConcatParameters$");
                    \}
                    return MapToDto(entity);
                \});

                return result;
            \}
            catch (Exception ex) when (ex is not DynamicContextException) {
                throw new DatabaseOperationException("$model.RootNamespace$", "GetById", "$model.Entity.Name$", ex);
            \}
        \}

    
        public async Task<Get$model.Entity.Name$Dto> CreateAsync(Create$model.Entity.Name$Dto createDto) {
            if (createDto == null) {
                throw new EntityValidationException("$model.RootNamespace$", "$model.Entity.Name$", "Create DTO cannot be null");
            \}
    
            try {
                var entity = MapToEntity(createDto);
                var result = await _repository.CreateAsync(entity);
                    
                // Invalidate collection cache
                await InvalidateCollectionCacheAsync();
                    
                _logger.LogInformation(\$"Created new $model.Entity.Name$");
                return MapToDto(result);
            \}
            catch (Exception ex) when (ex is not DynamicContextException) {
                throw new DatabaseOperationException("$model.RootNamespace$", "Create", "$model.Entity.Name$", ex);
            \}
        \}
    
        public async Task<Get$model.Entity.Name$Dto?> UpdateAsync($model.Entity.MethodSignatureParameter$, Update$model.Entity.Name$Dto updateDto) {
            $model.Entity.ParametersNamesArray: {parameter|
                if ($parameter$ == null) {
                    throw new EntityValidationException("$model.RootNamespace$", "$model.Entity.Name$", "$parameter$ cannot be null");
                \}
            }$
            if (updateDto == null) {
                throw new EntityValidationException("$model.RootNamespace$", "$model.Entity.Name$", "Update DTO cannot be null");
            \}
    
            try {
                var entity = MapToEntity(updateDto, $model.Entity.KeyParameterLine$);
                var result = await _repository.UpdateAsync($model.Entity.KeyParameterLine$, entity);
                    
                if (result == null) {
                    throw new EntityNotFoundException("$model.RootNamespace$", "$model.Entity.Name$", \$"$model.Entity.StringConcatParameters$");
                \}
    
                // Invalidate individual cache
                var cacheKey = \$"$model.Entity.Name$_GetById_$model.Entity.CacheKeyIdentifier$";
                await _cache.RemoveAsync(cacheKey);
    
                // Invalidate collection cache
                await InvalidateCollectionCacheAsync();
    
                _logger.LogInformation(\$"Updated $model.Entity.Name$ with id $model.Entity.StringConcatParameters$");
                return MapToDto(result);
            \}
            catch (Exception ex) when (ex is not DynamicContextException) {
                throw new DatabaseOperationException("$model.RootNamespace$", "Update", "$model.Entity.Name$", ex);
            \}
        \}
    
        public async Task<bool> DeleteAsync($model.Entity.MethodSignatureParameter$) {
            $model.Entity.ParametersNamesArray: {parameter|
                if ($parameter$ == null) {
                    throw new EntityValidationException("$model.RootNamespace$", "$model.Entity.Name$", "$parameter$ cannot be null");
                \}
            }$
    
            try {
                var deleted = await _repository.DeleteAsync($model.Entity.KeyParameterLine$);
                    
                if (!deleted) {
                    throw new EntityNotFoundException("$model.RootNamespace$", "$model.Entity.Name$", \$"$model.Entity.StringConcatParameters$");
                \}
    
                // Invalidate individual cache
                var cacheKey = \$"$model.Entity.Name$_GetById_$model.Entity.CacheKeyIdentifier$";
                await _cache.RemoveAsync(cacheKey);
    
                // Invalidate collection cache
                await InvalidateCollectionCacheAsync();
    
                _logger.LogInformation(\$"Deleted $model.Entity.Name$ with id $model.Entity.StringConcatParameters$");
                return true;
            \}
            catch (Exception ex) when (ex is not DynamicContextException) {
                throw new DatabaseOperationException("$model.RootNamespace$", "Delete", "$model.Entity.Name$", ex);
            \}
        \}
    $endif$
    public async Task<List<string>> ColumnUniqueValuesAsync(string column) {
        if (string.IsNullOrEmpty(column)) {
            throw new EntityValidationException("$model.RootNamespace$", "$model.Entity.Name$", "Column name cannot be null or empty");
        \}

        try {
            var cacheKey = "$model.Entity.Name$_UniqueValues_" + column;
            return await ExecuteCacheOperationAsync("$model.RootNamespace$", "GetUniqueValues", cacheKey, async () => {
                var values = await _repository.GetUniqueValuesForColumnAsync(column);
                return values ?? new List<string>();
            \});
        \}
        catch (Exception ex) when (ex is not DynamicContextException) {
            throw new DatabaseOperationException("$model.RootNamespace$", "GetUniqueValues", "$model.Entity.Name$", ex);
        \}
    \}
\}